#!/usr/bin/env bun
// @generated by mcporter@0.7.3 on 2026-01-21T00:44:22.721Z. DO NOT EDIT.
import { Command } from 'commander';
import { createRuntime, createServerProxy } from 'mcporter';
import { createCallResult } from 'mcporter';

const embeddedServer = {
  "name": "calendly",
  "description": "calendly-mcp-server",
  "command": {
    "kind": "stdio",
    "command": "node",
    "args": [
      "/tmp/calendly-work/calendly-mcp-server/dist/index.js"
    ],
    "cwd": "/tmp/calendly-work/calendly-clawdbot-skill"
  },
  "env": {
    "CALENDLY_API_KEY": "${CALENDLY_API_KEY}"
  },
  "source": {
    "kind": "local",
    "path": "/tmp/calendly-work/calendly-clawdbot-skill/mcporter.json"
  },
  "sources": [
    {
      "kind": "local",
      "path": "/tmp/calendly-work/calendly-clawdbot-skill/mcporter.json"
    }
  ]
} as const;
const embeddedSchemas = {
  "get_oauth_url": {
    "type": "object",
    "properties": {
      "redirect_uri": {
        "type": "string",
        "description": "The redirect URI for your OAuth application"
      },
      "state": {
        "type": "string",
        "description": "Optional state parameter for security"
      }
    },
    "required": [
      "redirect_uri"
    ]
  },
  "exchange_code_for_tokens": {
    "type": "object",
    "properties": {
      "code": {
        "type": "string",
        "description": "The authorization code from OAuth callback"
      },
      "redirect_uri": {
        "type": "string",
        "description": "The redirect URI used in authorization"
      }
    },
    "required": [
      "code",
      "redirect_uri"
    ]
  },
  "refresh_access_token": {
    "type": "object",
    "properties": {
      "refresh_token": {
        "type": "string",
        "description": "The refresh token to use"
      }
    },
    "required": [
      "refresh_token"
    ]
  },
  "get_current_user": {
    "type": "object",
    "properties": {},
    "required": []
  },
  "list_events": {
    "type": "object",
    "properties": {
      "user_uri": {
        "type": "string",
        "description": "URI of the user whose events to list"
      },
      "organization_uri": {
        "type": "string",
        "description": "URI of the organization to filter events"
      },
      "status": {
        "type": "string",
        "enum": [
          "active",
          "canceled"
        ],
        "description": "Filter events by status"
      },
      "max_start_time": {
        "type": "string",
        "description": "Maximum start time for events (ISO 8601 format)"
      },
      "min_start_time": {
        "type": "string",
        "description": "Minimum start time for events (ISO 8601 format)"
      },
      "count": {
        "type": "number",
        "description": "Number of events to return (default 20, max 100)"
      }
    },
    "required": []
  },
  "get_event": {
    "type": "object",
    "properties": {
      "event_uuid": {
        "type": "string",
        "description": "UUID of the event to retrieve"
      }
    },
    "required": [
      "event_uuid"
    ]
  },
  "list_event_invitees": {
    "type": "object",
    "properties": {
      "event_uuid": {
        "type": "string",
        "description": "UUID of the event"
      },
      "status": {
        "type": "string",
        "enum": [
          "active",
          "canceled"
        ],
        "description": "Filter invitees by status"
      },
      "email": {
        "type": "string",
        "description": "Filter invitees by email"
      },
      "count": {
        "type": "number",
        "description": "Number of invitees to return (default 20, max 100)"
      }
    },
    "required": [
      "event_uuid"
    ]
  },
  "cancel_event": {
    "type": "object",
    "properties": {
      "event_uuid": {
        "type": "string",
        "description": "UUID of the event to cancel"
      },
      "reason": {
        "type": "string",
        "description": "Reason for cancellation"
      }
    },
    "required": [
      "event_uuid"
    ]
  },
  "list_organization_memberships": {
    "type": "object",
    "properties": {
      "user_uri": {
        "type": "string",
        "description": "URI of the user"
      },
      "organization_uri": {
        "type": "string",
        "description": "URI of the organization"
      },
      "email": {
        "type": "string",
        "description": "Filter by email"
      },
      "count": {
        "type": "number",
        "description": "Number of memberships to return (default 20, max 100)"
      }
    },
    "required": []
  },
  "list_event_types": {
    "type": "object",
    "properties": {
      "user": {
        "type": "string",
        "description": "URI of the user whose event types to list"
      },
      "organization": {
        "type": "string",
        "description": "URI of the organization to filter event types"
      },
      "count": {
        "type": "number",
        "description": "Number of event types to return (default 20, max 100)"
      }
    },
    "required": []
  },
  "get_event_type_availability": {
    "type": "object",
    "properties": {
      "event_type": {
        "type": "string",
        "description": "URI of the event type to check availability for"
      },
      "start_time": {
        "type": "string",
        "description": "Start time for availability window (ISO 8601 format)"
      },
      "end_time": {
        "type": "string",
        "description": "End time for availability window (ISO 8601 format)"
      }
    },
    "required": [
      "event_type"
    ]
  },
  "schedule_event": {
    "type": "object",
    "properties": {
      "event_type": {
        "type": "string",
        "description": "URI of the event type to schedule"
      },
      "start_time": {
        "type": "string",
        "description": "Start time for the event (ISO 8601 UTC format, e.g., 2025-10-02T18:30:00Z)"
      },
      "invitee_name": {
        "type": "string",
        "description": "Full name of the invitee (alternative to first_name/last_name)"
      },
      "invitee_first_name": {
        "type": "string",
        "description": "First name of the invitee"
      },
      "invitee_last_name": {
        "type": "string",
        "description": "Last name of the invitee"
      },
      "invitee_email": {
        "type": "string",
        "description": "Email address of the invitee"
      },
      "invitee_timezone": {
        "type": "string",
        "description": "Timezone of the invitee (e.g., America/New_York)"
      },
      "invitee_phone": {
        "type": "string",
        "description": "Phone number for SMS reminders (E.164 format, e.g., +14155551234)"
      },
      "location_kind": {
        "type": "string",
        "description": "Type of meeting location (e.g., zoom_conference, google_conference, physical, ask_invitee)"
      },
      "location_details": {
        "type": "string",
        "description": "Location details (required for physical meetings or custom locations)"
      },
      "event_guests": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Array of additional email addresses to include (max 10)"
      },
      "questions_and_answers": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "question": {
              "type": "string",
              "description": "The question text (must match exactly)"
            },
            "answer": {
              "type": "string",
              "description": "The answer to the question"
            },
            "position": {
              "type": "number",
              "description": "Position of the question"
            }
          },
          "required": [
            "question",
            "answer",
            "position"
          ]
        },
        "description": "Array of question and answer pairs for booking form"
      },
      "utm_source": {
        "type": "string",
        "description": "UTM tracking parameter for source"
      },
      "utm_campaign": {
        "type": "string",
        "description": "UTM tracking parameter for campaign"
      },
      "utm_medium": {
        "type": "string",
        "description": "UTM tracking parameter for medium"
      }
    },
    "required": [
      "event_type",
      "start_time",
      "invitee_email",
      "invitee_timezone"
    ]
  }
} as const;
const embeddedName = "calendly";
const embeddedDescription = "calendly-mcp-server";
const generatorInfo = "Generated by mcporter@0.7.3 â€” https://github.com/steipete/mcporter";
const generatorTools = [
  {
    "name": "get-oauth-url",
    "description": "Generate OAuth authorization URL for user authentication",
    "usage": "get-oauth-url --redirect-uri <redirect-uri> [--state <state>] [--raw <json>]",
    "flags": "--redirect-uri <redirect-uri> [--state <state>] [--raw <json>]"
  },
  {
    "name": "exchange-code-for-tokens",
    "description": "Exchange authorization code for access and refresh tokens",
    "usage": "exchange-code-for-tokens --code <code> --redirect-uri <redirect-uri> [--raw <json>]",
    "flags": "--code <code> --redirect-uri <redirect-uri> [--raw <json>]"
  },
  {
    "name": "refresh-access-token",
    "description": "Refresh access token using refresh token",
    "usage": "refresh-access-token --refresh-token <refresh-token> [--raw <json>]",
    "flags": "--refresh-token <refresh-token> [--raw <json>]"
  },
  {
    "name": "get-current-user",
    "description": "Get the current authenticated user information",
    "usage": "get-current-user [--raw <json>]",
    "flags": "[--raw <json>]"
  },
  {
    "name": "list-events",
    "description": "List scheduled events for the authenticated user",
    "usage": "list-events [--user-uri <user-uri>] [--organization-uri <organization-uri>] [--status <status:active|canceled>] [--max-start-time <max-start-time:iso-8601>] [--min-start-time <min-start-time:iso-8601>] [--raw <json>]",
    "flags": "[--user-uri <user-uri>] [--organization-uri <organization-uri>] [--status <status:active|canceled>] [--max-start-time <max-start-time:iso-8601>] [--min-start-time <min-start-time:iso-8601>] [--raw <json>]"
  },
  {
    "name": "get-event",
    "description": "Get details of a specific event",
    "usage": "get-event --event-uuid <event-uuid> [--raw <json>]",
    "flags": "--event-uuid <event-uuid> [--raw <json>]"
  },
  {
    "name": "list-event-invitees",
    "description": "List invitees for a specific event",
    "usage": "list-event-invitees --event-uuid <event-uuid> [--status <status:active|canceled>] [--email <email>] [--count <count:number>] [--raw <json>]",
    "flags": "--event-uuid <event-uuid> [--status <status:active|canceled>] [--email <email>] [--count <count:number>] [--raw <json>]"
  },
  {
    "name": "cancel-event",
    "description": "Cancel a specific event",
    "usage": "cancel-event --event-uuid <event-uuid> [--reason <reason>] [--raw <json>]",
    "flags": "--event-uuid <event-uuid> [--reason <reason>] [--raw <json>]"
  },
  {
    "name": "list-organization-memberships",
    "description": "List organization memberships for the authenticated user",
    "usage": "list-organization-memberships [--user-uri <user-uri>] [--organization-uri <organization-uri>] [--email <email>] [--count <count:number>] [--raw <json>]",
    "flags": "[--user-uri <user-uri>] [--organization-uri <organization-uri>] [--email <email>] [--count <count:number>] [--raw <json>]"
  },
  {
    "name": "list-event-types",
    "description": "List available event types for scheduling meetings",
    "usage": "list-event-types [--user <user>] [--organization <organization>] [--count <count:number>] [--raw <json>]",
    "flags": "[--user <user>] [--organization <organization>] [--count <count:number>] [--raw <json>]"
  },
  {
    "name": "get-event-type-availability",
    "description": "Get available time slots for a specific event type",
    "usage": "get-event-type-availability --event-type <event-type> [--start-time <start-time:iso-8601>] [--end-time <end-time:iso-8601>] [--raw <json>]",
    "flags": "--event-type <event-type> [--start-time <start-time:iso-8601>] [--end-time <end-time:iso-8601>] [--raw <json>]"
  },
  {
    "name": "schedule-event",
    "description": "Schedule a meeting by creating an invitee for a specific event type and time",
    "usage": "schedule-event --event-type <event-type> --start-time <start-time:iso-8601> [--invitee-name <invitee-name>] --invitee-email <invitee-email> --invitee-timezone <invitee-timezone> [--raw <json>]",
    "flags": "--event-type <event-type> --start-time <start-time:iso-8601> [--invitee-name <invitee-name>] --invitee-email <invitee-email> --invitee-timezone <invitee-timezone> [--raw <json>]"
  }
] as const;
const embeddedMetadata = {
  "schemaVersion": 1,
  "generatedAt": "2026-01-21T00:44:22.721Z",
  "generator": {
    "name": "mcporter",
    "version": "0.7.3"
  },
  "server": {
    "name": "calendly",
    "source": {
      "kind": "local",
      "path": "/tmp/calendly-work/calendly-clawdbot-skill/mcporter.json"
    },
    "definition": {
      "name": "calendly",
      "description": "calendly-mcp-server",
      "command": {
        "kind": "stdio",
        "command": "node",
        "args": [
          "/tmp/calendly-work/calendly-mcp-server/dist/index.js"
        ],
        "cwd": "/tmp/calendly-work/calendly-clawdbot-skill"
      },
      "env": {
        "CALENDLY_API_KEY": "${CALENDLY_API_KEY}"
      }
    }
  },
  "artifact": {
    "path": "",
    "kind": "template"
  },
  "invocation": {
    "serverRef": "calendly",
    "configPath": "/tmp/calendly-work/calendly-clawdbot-skill/mcporter.json",
    "runtime": "bun",
    "bundler": "bun",
    "outputPath": "calendly",
    "timeoutMs": 30000,
    "minify": false
  }
} as const;
const artifactKind = determineArtifactKind();
const program = new Command();
program.name(embeddedName);
program.description(embeddedDescription);
program.option('-t, --timeout <ms>', 'Call timeout in milliseconds', (value) => parseInt(value, 10), 30000);
program.option('-o, --output <format>', 'Output format: text|markdown|json|raw', 'text');
const commandSignatures: Record<string, string> = {
  "get-oauth-url": "function get_oauth_url(redirect_uri: string, state?: string);",
  "exchange-code-for-tokens": "function exchange_code_for_tokens(code: string, redirect_uri: string);",
  "refresh-access-token": "function refresh_access_token(refresh_token: string);",
  "get-current-user": "function get_current_user();",
  "list-events": "function list_events(user_uri?: string, organization_uri?: string, status?: \"active\" | \"canceled\", max_start_time?: string, min_start_time?: string);",
  "get-event": "function get_event(event_uuid: string);",
  "list-event-invitees": "function list_event_invitees(event_uuid: string, status?: \"active\" | \"canceled\", email?: string, count?: number);",
  "cancel-event": "function cancel_event(event_uuid: string, reason?: string);",
  "list-organization-memberships": "function list_organization_memberships(user_uri?: string, organization_uri?: string, email?: string, count?: number);",
  "list-event-types": "function list_event_types(user?: string, organization?: string, count?: number);",
  "get-event-type-availability": "function get_event_type_availability(event_type: string, start_time?: string, end_time?: string);",
  "schedule-event": "function schedule_event(event_type: string, start_time: string, invitee_name?: string, invitee_email: string, invitee_timezone: string);"
};
program.configureHelp({
	commandTerm(cmd) {
		const term = cmd.name();
		return commandSignatures[term] ?? cmd.name();
	},
});
program.showSuggestionAfterError(true);

program
	.command("get-oauth-url")
	.summary("get-oauth-url --redirect-uri <redirect-uri> [--state <state>] [--raw <json>]")
	.description("Generate OAuth authorization URL for user authentication")
	.usage("--redirect-uri <redirect-uri> [--state <state>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--redirect-uri <redirect-uri>", "The redirect URI for your OAuth application")
	.option("--state <state>", "Optional state parameter for security")
	
	.alias("get_oauth_url")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.redirectUri !== undefined) args.redirect_uri = cmdOpts.redirectUri;
		if (cmdOpts.state !== undefined) args.state = cmdOpts.state;
			const call = (proxy.getOauthUrl as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call calendly.get_oauth_url(redirect_uri: \"value\")");

program
	.command("exchange-code-for-tokens")
	.summary("exchange-code-for-tokens --code <code> --redirect-uri <redirect-uri> [--raw <json>]")
	.description("Exchange authorization code for access and refresh tokens")
	.usage("--code <code> --redirect-uri <redirect-uri> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--code <code>", "The authorization code from OAuth callback")
	.requiredOption("--redirect-uri <redirect-uri>", "The redirect URI used in authorization")
	
	.alias("exchange_code_for_tokens")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.code !== undefined) args.code = cmdOpts.code;
		if (cmdOpts.redirectUri !== undefined) args.redirect_uri = cmdOpts.redirectUri;
			const call = (proxy.exchangeCodeForTokens as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call calendly.exchange_code_for_tokens(code: \"value\", redirect_ur, ...)");

program
	.command("refresh-access-token")
	.summary("refresh-access-token --refresh-token <refresh-token> [--raw <json>]")
	.description("Refresh access token using refresh token")
	.usage("--refresh-token <refresh-token> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--refresh-token <refresh-token>", "The refresh token to use")
	
	.alias("refresh_access_token")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.refreshToken !== undefined) args.refresh_token = cmdOpts.refreshToken;
			const call = (proxy.refreshAccessToken as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call calendly.refresh_access_token(refresh_token: \"value\")");

program
	.command("get-current-user")
	.summary("get-current-user [--raw <json>]")
	.description("Get the current authenticated user information")
	.usage("[--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	
	.alias("get_current_user")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			
			const call = (proxy.getCurrentUser as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call calendly.get_current_user()");

program
	.command("list-events")
	.summary("list-events [--user-uri <user-uri>] [--organization-uri <organization-uri>] [--status <status:active|canceled>] [--max-start-time <max-start-time:iso-8601>] [--min-start-time <min-start-time:iso-8601>] [--raw <json>]")
	.description("List scheduled events for the authenticated user")
	.usage("[--user-uri <user-uri>] [--organization-uri <organization-uri>] [--status <status:active|canceled>] [--max-start-time <max-start-time:iso-8601>] [--min-start-time <min-start-time:iso-8601>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--user-uri <user-uri>", "URI of the user whose events to list")
	.option("--organization-uri <organization-uri>", "URI of the organization to filter events")
	.option("--status <status:active|canceled>", "Filter events by status (choices: active, canceled; example: active)")
	.option("--max-start-time <max-start-time:iso-8601>", "Maximum start time for events (ISO 8601 format)")
	.option("--min-start-time <min-start-time:iso-8601>", "Minimum start time for events (ISO 8601 format)")
	.option("--count <count:number>", "Number of events to return (default 20, max 100) (example: 1)", (value) => parseFloat(value))
	
	.alias("list_events")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.userUri !== undefined) args.user_uri = cmdOpts.userUri;
		if (cmdOpts.organizationUri !== undefined) args.organization_uri = cmdOpts.organizationUri;
		if (cmdOpts.status !== undefined) args.status = cmdOpts.status;
		if (cmdOpts.maxStartTime !== undefined) args.max_start_time = cmdOpts.maxStartTime;
		if (cmdOpts.minStartTime !== undefined) args.min_start_time = cmdOpts.minStartTime;
		if (cmdOpts.count !== undefined) args.count = cmdOpts.count;
			const call = (proxy.listEvents as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call calendly.list_events(status: \"active\")")
	.addHelpText('afterAll', () => '\n' + "// optional (1): count" + '\n');

program
	.command("get-event")
	.summary("get-event --event-uuid <event-uuid> [--raw <json>]")
	.description("Get details of a specific event")
	.usage("--event-uuid <event-uuid> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--event-uuid <event-uuid>", "UUID of the event to retrieve (example: example-id)")
	
	.alias("get_event")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.eventUuid !== undefined) args.event_uuid = cmdOpts.eventUuid;
			const call = (proxy.getEvent as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call calendly.get_event(event_uuid: \"example-id\")");

program
	.command("list-event-invitees")
	.summary("list-event-invitees --event-uuid <event-uuid> [--status <status:active|canceled>] [--email <email>] [--count <count:number>] [--raw <json>]")
	.description("List invitees for a specific event")
	.usage("--event-uuid <event-uuid> [--status <status:active|canceled>] [--email <email>] [--count <count:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--event-uuid <event-uuid>", "UUID of the event (example: example-id)")
	.option("--status <status:active|canceled>", "Filter invitees by status (choices: active, canceled; example: active)")
	.option("--email <email>", "Filter invitees by email")
	.option("--count <count:number>", "Number of invitees to return (default 20, max 100) (example: 1)", (value) => parseFloat(value))
	
	.alias("list_event_invitees")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.eventUuid !== undefined) args.event_uuid = cmdOpts.eventUuid;
		if (cmdOpts.status !== undefined) args.status = cmdOpts.status;
		if (cmdOpts.email !== undefined) args.email = cmdOpts.email;
		if (cmdOpts.count !== undefined) args.count = cmdOpts.count;
			const call = (proxy.listEventInvitees as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call calendly.list_event_invitees(event_uuid: \"example-id\", statu, ...)");

program
	.command("cancel-event")
	.summary("cancel-event --event-uuid <event-uuid> [--reason <reason>] [--raw <json>]")
	.description("Cancel a specific event")
	.usage("--event-uuid <event-uuid> [--reason <reason>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--event-uuid <event-uuid>", "UUID of the event to cancel (example: example-id)")
	.option("--reason <reason>", "Reason for cancellation")
	
	.alias("cancel_event")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.eventUuid !== undefined) args.event_uuid = cmdOpts.eventUuid;
		if (cmdOpts.reason !== undefined) args.reason = cmdOpts.reason;
			const call = (proxy.cancelEvent as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call calendly.cancel_event(event_uuid: \"example-id\")");

program
	.command("list-organization-memberships")
	.summary("list-organization-memberships [--user-uri <user-uri>] [--organization-uri <organization-uri>] [--email <email>] [--count <count:number>] [--raw <json>]")
	.description("List organization memberships for the authenticated user")
	.usage("[--user-uri <user-uri>] [--organization-uri <organization-uri>] [--email <email>] [--count <count:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--user-uri <user-uri>", "URI of the user")
	.option("--organization-uri <organization-uri>", "URI of the organization")
	.option("--email <email>", "Filter by email")
	.option("--count <count:number>", "Number of memberships to return (default 20, max 100) (example: 1)", (value) => parseFloat(value))
	
	.alias("list_organization_memberships")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.userUri !== undefined) args.user_uri = cmdOpts.userUri;
		if (cmdOpts.organizationUri !== undefined) args.organization_uri = cmdOpts.organizationUri;
		if (cmdOpts.email !== undefined) args.email = cmdOpts.email;
		if (cmdOpts.count !== undefined) args.count = cmdOpts.count;
			const call = (proxy.listOrganizationMemberships as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call calendly.list_organization_memberships(count: 1)");

program
	.command("list-event-types")
	.summary("list-event-types [--user <user>] [--organization <organization>] [--count <count:number>] [--raw <json>]")
	.description("List available event types for scheduling meetings")
	.usage("[--user <user>] [--organization <organization>] [--count <count:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--user <user>", "URI of the user whose event types to list")
	.option("--organization <organization>", "URI of the organization to filter event types")
	.option("--count <count:number>", "Number of event types to return (default 20, max 100) (example: 1)", (value) => parseFloat(value))
	
	.alias("list_event_types")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.user !== undefined) args.user = cmdOpts.user;
		if (cmdOpts.organization !== undefined) args.organization = cmdOpts.organization;
		if (cmdOpts.count !== undefined) args.count = cmdOpts.count;
			const call = (proxy.listEventTypes as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call calendly.list_event_types(count: 1)");

program
	.command("get-event-type-availability")
	.summary("get-event-type-availability --event-type <event-type> [--start-time <start-time:iso-8601>] [--end-time <end-time:iso-8601>] [--raw <json>]")
	.description("Get available time slots for a specific event type")
	.usage("--event-type <event-type> [--start-time <start-time:iso-8601>] [--end-time <end-time:iso-8601>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--event-type <event-type>", "URI of the event type to check availability for")
	.option("--start-time <start-time:iso-8601>", "Start time for availability window (ISO 8601 format)")
	.option("--end-time <end-time:iso-8601>", "End time for availability window (ISO 8601 format)")
	
	.alias("get_event_type_availability")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.eventType !== undefined) args.event_type = cmdOpts.eventType;
		if (cmdOpts.startTime !== undefined) args.start_time = cmdOpts.startTime;
		if (cmdOpts.endTime !== undefined) args.end_time = cmdOpts.endTime;
			const call = (proxy.getEventTypeAvailability as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call calendly.get_event_type_availability(event_type: \"value\")");

program
	.command("schedule-event")
	.summary("schedule-event --event-type <event-type> --start-time <start-time:iso-8601> [--invitee-name <invitee-name>] --invitee-email <invitee-email> --invitee-timezone <invitee-timezone> [--raw <json>]")
	.description("Schedule a meeting by creating an invitee for a specific event type and time")
	.usage("--event-type <event-type> --start-time <start-time:iso-8601> [--invitee-name <invitee-name>] --invitee-email <invitee-email> --invitee-timezone <invitee-timezone> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--event-type <event-type>", "URI of the event type to schedule")
	.requiredOption("--start-time <start-time:iso-8601>", "Start time for the event (ISO 8601 UTC format, e.g., 2025-10-02T18:30:00Z)")
	.option("--invitee-name <invitee-name>", "Full name of the invitee (alternative to first_name/last_name)")
	.option("--invitee-first-name <invitee-first-name>", "First name of the invitee")
	.option("--invitee-last-name <invitee-last-name>", "Last name of the invitee")
	.requiredOption("--invitee-email <invitee-email>", "Email address of the invitee")
	.requiredOption("--invitee-timezone <invitee-timezone>", "Timezone of the invitee (e.g., America/New_York)")
	.option("--invitee-phone <invitee-phone>", "Phone number for SMS reminders (E.164 format, e.g., +14155551234)")
	.option("--location-kind <location-kind>", "Type of meeting location (e.g., zoom_conference, google_conference, physical, ask_invitee)")
	.option("--location-details <location-details>", "Location details (required for physical meetings or custom locations)")
	.option("--event-guests <event-guests:value1,value2>", "Array of additional email addresses to include (max 10) (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--questions-and-answers <questions-and-answers:value1,value2>", "Array of question and answer pairs for booking form (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--utm-source <utm-source>", "UTM tracking parameter for source")
	.option("--utm-campaign <utm-campaign>", "UTM tracking parameter for campaign")
	.option("--utm-medium <utm-medium>", "UTM tracking parameter for medium")
	
	.alias("schedule_event")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.eventType !== undefined) args.event_type = cmdOpts.eventType;
		if (cmdOpts.startTime !== undefined) args.start_time = cmdOpts.startTime;
		if (cmdOpts.inviteeName !== undefined) args.invitee_name = cmdOpts.inviteeName;
		if (cmdOpts.inviteeFirstName !== undefined) args.invitee_first_name = cmdOpts.inviteeFirstName;
		if (cmdOpts.inviteeLastName !== undefined) args.invitee_last_name = cmdOpts.inviteeLastName;
		if (cmdOpts.inviteeEmail !== undefined) args.invitee_email = cmdOpts.inviteeEmail;
		if (cmdOpts.inviteeTimezone !== undefined) args.invitee_timezone = cmdOpts.inviteeTimezone;
		if (cmdOpts.inviteePhone !== undefined) args.invitee_phone = cmdOpts.inviteePhone;
		if (cmdOpts.locationKind !== undefined) args.location_kind = cmdOpts.locationKind;
		if (cmdOpts.locationDetails !== undefined) args.location_details = cmdOpts.locationDetails;
		if (cmdOpts.eventGuests !== undefined) args.event_guests = cmdOpts.eventGuests;
		if (cmdOpts.questionsAndAnswers !== undefined) args.questions_and_answers = cmdOpts.questionsAndAnswers;
		if (cmdOpts.utmSource !== undefined) args.utm_source = cmdOpts.utmSource;
		if (cmdOpts.utmCampaign !== undefined) args.utm_campaign = cmdOpts.utmCampaign;
		if (cmdOpts.utmMedium !== undefined) args.utm_medium = cmdOpts.utmMedium;
			const call = (proxy.scheduleEvent as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call calendly.schedule_event(event_type: \"value\", start_time: \"va, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (10): invitee_first_name, invitee_last_name, invitee_phone, location_kind, location_details, ..." + '\n');

program
	.command('__mcporter_inspect', { hidden: true })
	.description('Internal metadata printer for mcporter inspect-cli.')
	.action(() => {
		const payload = buildMetadataPayload();
		console.log(JSON.stringify(payload, null, 2));
	});

configureToolCommandHelps();

const FORCE_COLOR = process.env.FORCE_COLOR?.toLowerCase();
const forceDisableColor = FORCE_COLOR === '0' || FORCE_COLOR === 'false';
const forceEnableColor = FORCE_COLOR === '1' || FORCE_COLOR === 'true' || FORCE_COLOR === '2' || FORCE_COLOR === '3';
const hasNoColor = process.env.NO_COLOR !== undefined;
const stdoutStream = process.stdout as NodeJS.WriteStream | undefined;
const supportsAnsiColor = !hasNoColor && (forceEnableColor || (!forceDisableColor && Boolean(stdoutStream?.isTTY)));

const tint = {
	bold(text: string): string {
		return supportsAnsiColor ? '[1m' + text + '[0m' : text;
	},
	dim(text: string): string {
		return supportsAnsiColor ? '[90m' + text + '[0m' : text;
	},
	extraDim(text: string): string {
		return supportsAnsiColor ? '[38;5;244m' + text + '[0m' : text;
	},
};

function configureGeneratedCommandHelp(command: Command): void {
	command.configureHelp({
		commandUsage(target) {
			const usage = (target.name() + ' ' + target.usage()).trim() || target.name();
			return supportsAnsiColor ? tint.bold(usage) : usage;
		},
		optionTerm(option) {
			const term = option.flags ?? '';
			return supportsAnsiColor ? tint.bold(term) : term;
		},
		optionDescription(option) {
			const description = option.description ?? '';
			return supportsAnsiColor ? tint.extraDim(description) : description;
		},
	});
}

function configureToolCommandHelps(): void {
	program.commands.forEach((cmd) => {
		if (cmd.name() === '__mcporter_inspect') {
			return;
		}
		configureGeneratedCommandHelp(cmd);
	});
}

function renderStandaloneHelp(): string {
	const colorfulTitle = tint.bold(embeddedName) + ' ' + tint.dim('â€” ' + embeddedDescription);
	const plainTitle = embeddedName + ' â€” ' + embeddedDescription;
	const title = supportsAnsiColor ? colorfulTitle : plainTitle;
	const lines = [title, '', 'Usage: ' + embeddedName + ' <command> [options]', ''];
	if (generatorTools) {
		lines.push(formatEmbeddedTools());
	}
	lines.push('', formatGlobalFlags(), '', formatQuickStart());
	if (generatorInfo) {
		lines.push('', tint.extraDim(generatorInfo));
	}
	return lines.join('\n');
}

program.helpInformation = () => renderStandaloneHelp();

function formatEmbeddedTools(): string {
	const header = supportsAnsiColor ? tint.bold('Embedded tools') : 'Embedded tools';
	if (!generatorTools.length) {
		return header;
	}
	const lines = [header];
	generatorTools.forEach((entry) => {
		const renderedDesc = entry.description
			? supportsAnsiColor
				? tint.extraDim(entry.description)
				: entry.description
			: undefined;
		const base = renderedDesc ? entry.name + ' - ' + renderedDesc : entry.name;
		lines.push('  ' + base);
		if (entry.flags) {
			const renderedFlags = supportsAnsiColor ? tint.extraDim(entry.flags) : entry.flags;
			lines.push('    ' + renderedFlags);
		}
		lines.push('');
	});
	if (lines[lines.length - 1] === '') {
		lines.pop();
	}
	return lines.join('\n');
}

function formatGlobalFlags(): string {
	const header = supportsAnsiColor ? tint.bold('Global flags') : 'Global flags';
	const entries = [
		['-t, --timeout <ms>', 'Call timeout in milliseconds'],
		['-o, --output <format>', 'text | markdown | json | raw (default text)'],
	];
	const formatted = entries.map(([flag, summary]) => '  ' + flag.padEnd(28) + summary);
	return [header, ...formatted].join('\n');
}

function formatQuickStart(): string {
  const header = supportsAnsiColor ? tint.bold('Quick start') : 'Quick start';
  const examples = quickStartExamples();
  if (!examples.length) {
    return header;
  }
  const formatted = examples.map(([cmd, note]) => '  ' + cmd + '\n    ' + tint.dim('# ' + note));
  return [header, ...formatted].join('\n');
}

function quickStartExamples(): Array<[string, string]> {
  const examples: Array<[string, string]> = [];
  const commandMap = new Map<string, string>();
  program.commands.forEach((cmd) => {
    const name = cmd.name();
    if (name !== '__mcporter_inspect') {
      commandMap.set(name, name);
    }
  });
  const embedded = Array.isArray(generatorTools) ? generatorTools : [];
  for (const entry of embedded.slice(0, 3)) {
    const commandName = commandMap.get(entry.name) ?? entry.name;
    const flags = entry.flags ? ' ' + entry.flags.replace(/<[^>]+>/g, '<value>') : '';
    examples.push([embeddedName + ' ' + commandName + flags, 'invoke ' + commandName]);
  }
  if (!examples.length) {
    examples.push([embeddedName + ' <tool> --key value', 'invoke a tool with flags']);
  }
  return examples;
}

function printResult(result: unknown, format: string) {
	const wrapped = createCallResult(result);
	switch (format) {
		case 'json': {
			const json = wrapped.json();
			if (json) {
				console.log(JSON.stringify(json, null, 2));
				return;
			}
			break;
		}
		case 'markdown': {
			const markdown = wrapped.markdown();
			if (markdown) {
				console.log(markdown);
				return;
			}
			break;
		}
		case 'raw': {
			console.log(JSON.stringify(wrapped.raw, null, 2));
			return;
		}
	}
	const text = wrapped.text();
	if (text) {
		console.log(text);
	} else {
		console.log(JSON.stringify(wrapped.raw, null, 2));
	}
}

function normalizeEmbeddedServer(server: typeof embeddedServer) {
	const base = { ...server } as Record<string, unknown>;
	if ((server.command as any).kind === 'http') {
		const urlRaw = (server.command as any).url;
		const urlValue = typeof urlRaw === 'string' ? urlRaw : String(urlRaw);
		return {
			...base,
			command: {
				...(server.command as Record<string, unknown>),
				url: new URL(urlValue),
			},
		};
	}
	if ((server.command as any).kind === 'stdio') {
		return {
			...base,
			command: {
				...(server.command as Record<string, unknown>),
				args: [ ...((server.command as any).args ?? []) ],
			},
		};
	}
	return base;
}

function determineArtifactKind(): 'template' | 'bundle' | 'binary' {
	const scriptPath = typeof process !== 'undefined' && Array.isArray(process.argv) ? process.argv[1] ?? '' : '';
	if (scriptPath.endsWith('.ts')) {
		return 'template';
	}
	if (scriptPath.endsWith('.js')) {
		return 'bundle';
	}
	return 'binary';
}

function resolveArtifactPath(): string {
	if (typeof process !== 'undefined' && Array.isArray(process.argv) && process.argv.length > 1) {
		const script = process.argv[1];
		if (script) {
			return script;
		}
	}
	return embeddedMetadata.artifact.path;
}

function buildMetadataPayload() {
	const invocation = { ...embeddedMetadata.invocation };
	const path = resolveArtifactPath();
	if (artifactKind === 'template' && path) {
		invocation.outputPath = invocation.outputPath ?? path;
	} else if (artifactKind === 'bundle' && path) {
		invocation.bundle = invocation.bundle ?? path;
	} else if (artifactKind === 'binary' && path) {
		invocation.compile = invocation.compile ?? path;
	}
	return {
		...embeddedMetadata,
		artifact: {
			path,
			kind: artifactKind,
		},
		invocation,
	};
}

async function ensureRuntime(): Promise<Awaited<ReturnType<typeof createRuntime>>> {
	return await createRuntime({
		servers: [normalizeEmbeddedServer(embeddedServer)],
	});
}

async function invokeWithTimeout<T>(call: Promise<T>, timeout: number): Promise<T> {
	if (!Number.isFinite(timeout) || timeout <= 0) {
		return await call;
	}
	let timer: ReturnType<typeof setTimeout> | undefined;
	try {
		return await Promise.race([
			call,
			new Promise<never>((_, reject) => {
				timer = setTimeout(() => {
					reject(new Error('Call timed out after ' + timeout + 'ms.'));
				}, timeout);
			}),
		]);
	} finally {
		if (timer) {
			clearTimeout(timer);
		}
	}
}

async function runCli(): Promise<void> {
	const args = process.argv.slice(2);
	if (args.length === 0) {
		program.outputHelp();
		return;
	}
	await program.parseAsync(process.argv);
}

if (process.env.MCPORTER_DISABLE_AUTORUN !== '1') {
	runCli().catch((error) => {
		const message = error instanceof Error ? error.message : String(error);
		console.error(message);
		process.exit(1);
	});
}
